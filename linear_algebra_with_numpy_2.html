<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><link rel="shortcut icon" type="image/x-icon" href="/bigdata-lecture/images/favicon.ico"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>선형대수와 Numpy 프로그래밍 (2) | TensorFlow로 시작하는 머신러닝 &amp; 딥러닝</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="선형대수와 Numpy 프로그래밍 (2)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="머신러닝에 꼭 필요한 선형대수학 개념들을 배우고 이를 Numpy로 구현하는 방법을 배워봅시다." />
<meta property="og:description" content="머신러닝에 꼭 필요한 선형대수학 개념들을 배우고 이를 Numpy로 구현하는 방법을 배워봅시다." />
<link rel="canonical" href="https://gusdnd852.github.io/bigdata-lecture/linear_algebra_with_numpy_2" />
<meta property="og:url" content="https://gusdnd852.github.io/bigdata-lecture/linear_algebra_with_numpy_2" />
<meta property="og:site_name" content="TensorFlow로 시작하는 머신러닝 &amp; 딥러닝" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-07-15T00:00:00-05:00" />
<script type="application/ld+json">
{"url":"https://gusdnd852.github.io/bigdata-lecture/linear_algebra_with_numpy_2","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://gusdnd852.github.io/bigdata-lecture/linear_algebra_with_numpy_2"},"headline":"선형대수와 Numpy 프로그래밍 (2)","dateModified":"2020-07-15T00:00:00-05:00","datePublished":"2020-07-15T00:00:00-05:00","description":"머신러닝에 꼭 필요한 선형대수학 개념들을 배우고 이를 Numpy로 구현하는 방법을 배워봅시다.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <link href="https://unpkg.com/@primer/css/dist/primer.css" rel="stylesheet" />
  <link rel="stylesheet" href="//use.fontawesome.com/releases/v5.0.7/css/all.css">
    <link rel="stylesheet" href="/bigdata-lecture/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://gusdnd852.github.io/bigdata-lecture/feed.xml" title="TensorFlow로 시작하는 머신러닝 & 딥러닝" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
    <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"> </script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement( document.body, {
          delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "[%", right: "%]", display: true},
            {left: "$", right: "$", display: false}
          ]}
        );
      });
    </script>
  

  <script>
  function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
  }
  window.onload = wrap_img;
  </script>

  <script>
    document.addEventListener("DOMContentLoaded", function(){
      // add link icon to anchor tags
      var elem = document.querySelectorAll(".anchor-link")
      elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
      // remove paragraph tags in rendered toc (happens from notebooks)
      var toctags = document.querySelectorAll(".toc-entry")
      toctags.forEach(e => (e.firstElementChild.innerText = e.firstElementChild.innerText.replace('¶', '')))
    });
  </script>
</head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>

     @media screen and (max-width : 511px) {
         body { 
		font-size: 0.84rem; 
	}pre, code, blockquote {
		font-size: 0.84rem !important;
	}
	.katex, .mord {
		font: normal 1.02em 'KaTeX_Main', sans-serif !important;
	}
	.minner, .mord.mtight {
		font: normal 0.90em 'KaTeX_Main', sans-serif !important;
	}
	.page-meta {
		font-size: 0.9rem !important;
	}
	.contents-left{
		display: none !important;
	}
	.contents-right, .contents-left {
    		display: block;
    		text-align: center;
		margin-left: 0px !important;
    		margin-right: 0px !important;
    		list-style: none;
    	}
	.mobile_hide{
		display: none;
	}
	.contents-right > li {
    		display: inline-block;
    		margin: 3px;
    		word-break: keep-all;
	}
     }
 

     @media screen and (min-width : 512px) and (max-width : 767px) {
         body { 
		font-size: 0.92rem; 
	}pre, code, blockquote {
		font-size: 0.92rem !important;
	}
	.katex, .mord {
		font: normal 1.04em 'KaTeX_Main', sans-serif !important;
	}
	.minner, .mord.mtight {
		font: normal 0.92em 'KaTeX_Main', sans-serif !important;
	}
	.page-meta {
		font-size: 1.0rem !important;
	}
	.contents-left{
		display: none !important;
	}
	.contents-right, .contents-left {
    		display: block;
    		text-align: center;
		margin-left: 0px !important;
    		margin-right: 0px !important;
    		list-style: none;
    	}    
	.mobile_hide{
		display: none !important;
	}
	.contents-right > li {
    		display: inline-block;
    		margin: 3px;
    		word-break: keep-all;
	}
     }
 
     @media screen and (min-width : 768px) and (max-width : 1024px) {
         body {
		 font-size: 1.0rem; 
	}pre, code, blockquote {
		font-size: 1.0rem !important;
	}
	.katex, .mord {
		font: normal 1.05em 'KaTeX_Main', sans-serif !important;
	}
	.minner, .mord.mtight {
		font: normal 0.93em 'KaTeX_Main', sans-serif !important;
	}
	.page-meta {
		font-size: 1.1rem !important;
	}
	.contents-right, .contents-left {
		display: inline-block;
    		vertical-align: top;
    		text-align: left;
		list-style: none;
    	}  
	.contents-left{
		margin-left: 20px !important;
    		margin-right: 3.0rem;
	}
	.mobile_hide{
		display: block !important;
	}
     }

     @media screen and (min-width : 1025px) {
         body { 
		font-size: 1.08rem; 
	}pre, code, blockquote {
		font-size: 1.08rem !important;
	}
     	.katex, .mord {
		font: normal 1.06em 'KaTeX_Main', sans-serif !important;
	}
	.minner, .mord.mtight {
		font: normal 0.94em 'KaTeX_Main', sans-serif !important;
	}
	.page-meta {
		font-size: 1.2rem !important;
	}
	.contents-right, .contents-left {
    		display: inline-block;
    		vertical-align: top;
    		text-align: left;
		list-style: none;
    	}
	.contents-right > h2, .contents-left > h2 {
    		margin-botton: 2px
	}  
	.contents-left{
    		margin-left: 0 !important;
    		margin-right: 3.0rem;
	}
	.mobile_hide{
		display: block !important;
	}
     }

    </style>
  <body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" style="font-size:1.2rem;" href="/bigdata-lecture/">TensorFlow로 시작하는 머신러닝 &amp; 딥러닝 </a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/bigdata-lecture/lecture">Lecture</a><a class="page-link" href="/bigdata-lecture/orientation">Orientation</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content" style="flex: none;" >
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h3 class="post-title p-name" itemprop="name headline">04. 선형대수와 Numpy 프로그래밍 (2)</h3><p class="page-description">머신러닝에 꼭 필요한 선형대수학 개념들을 배우고 이를 Numpy로 구현하는 방법을 배워봅시다.</p
      <i class="fas fa-tags category-tags-icon"></i><p class="category-tags"> 
      
        
      
      </p>
    

    
      
        <div class="pb-5 d-flex flex-wrap flex-justify-end">
	
	<div class="px-1">
    <a href="https://colab.research.google.com/github/gusdnd852/bigdata-lecture/blob/master/_notebooks/01_04_선형대수와_numpy_프로그래밍_(2).ipynb" target="_blank">
        <img class="notebook-badge-image" src="/bigdata-lecture/assets/badges/colab.svg" alt="Open In Colab"/>
    </a>
</div>
	
	<div class="px-1">
<a href="https://github.com/gusdnd852/bigdata-lecture/tree/master/_notebooks/01_04_선형대수와_numpy_프로그래밍_(2).ipynb" role="button">
    <img class="notebook-badge-image" src="https://img.shields.io/static/v1?label=&message=View%20On%20GitHub&color=586069&logo=github&labelColor=2f363d">
</a>
</div>
        </div>
      </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ul class="section-nav">
<li class="toc-entry toc-h3"><a href="#1.-내적-(Inner-Product,-Dot-Product)">1. 내적 (Inner Product, Dot Product) </a>
<ul>
<li class="toc-entry toc-h4"><a href="#1.1.-벡터-벡터-내적-(Vector-Vector-Inner-Product)">1.1. 벡터-벡터 내적 (Vector-Vector Inner Product) </a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#2.-행렬">2. 행렬 </a>
<ul>
<li class="toc-entry toc-h4"><a href="#2.1.-변환-(Transformation)">2.1. 변환 (Transformation) </a></li>
<li class="toc-entry toc-h4"><a href="#2.2.-선형-변환-(Linear-Transformation)">2.2. 선형 변환 (Linear Transformation) </a></li>
<li class="toc-entry toc-h4"><a href="#2.3.-굳이-변환-이야기를-꺼내는-이유?">2.3. 굳이 변환 이야기를 꺼내는 이유? </a></li>
<li class="toc-entry toc-h4"><a href="#2.4.-행렬의-본질">2.4. 행렬의 본질 </a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#3.-Shape">3. Shape </a></li>
<li class="toc-entry toc-h3"><a href="#4.-행렬의-연산">4. 행렬의 연산 </a>
<ul>
<li class="toc-entry toc-h4"><a href="#4.1.-행렬-합-(=-벡터-합,-Matrix-Addition)">4.1. 행렬 합 (= 벡터 합, Matrix Addition) </a></li>
<li class="toc-entry toc-h4"><a href="#4.2.-스칼라-곱-(Scalar-Multiplication)">4.2. 스칼라 곱 (Scalar Multiplication) </a></li>
<li class="toc-entry toc-h4"><a href="#4.3.-원소곱-(Elementwise-Multiplication)">4.3. 원소곱 (Elementwise Multiplication) </a></li>
<li class="toc-entry toc-h4"><a href="#4.4.-행렬-벡터-내적-(Matrix-Vector-Inner-Product)">4.4. 행렬-벡터 내적 (Matrix-Vector Inner Product) </a></li>
<li class="toc-entry toc-h4"><a href="#4.5.-Shape-규칙-(Rule-of-multiplication)">4.5. Shape 규칙 (Rule of multiplication) </a></li>
<li class="toc-entry toc-h4"><a href="#4.6.-행렬-행렬-내적-(Matrix-Matrix-Inner-Product))">4.6. 행렬-행렬 내적 (Matrix-Matrix Inner Product)) </a></li>
<li class="toc-entry toc-h4"><a href="#4.7.-행렬내적의-교환법칙은-성립하지-않는다?">4.7. 행렬내적의 교환법칙은 성립하지 않는다? </a></li>
<li class="toc-entry toc-h4"><a href="#4.8.-더-높은-차원의-행렬">4.8. 더 높은 차원의 행렬 </a></li>
<li class="toc-entry toc-h4"><a href="#4.9.-벡터-벡터-내적-(Vector-Vector-Inner-Product)">4.9. 벡터-벡터 내적 (Vector-Vector Inner Product) </a></li>
</ul>
</li>
</ul><!--
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: _notebooks/01_04_선형대수와_numpy_프로그래밍_(2).ipynb
-->

<div class="container" id="notebook-container">
        
    
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>앞선 시간에서 선형대수의 대략적인 개념과 numpy를 소개했습니다. 이번 챕터에서는 이제 본격적으로 내적, 행렬, 선형대수의 각종 연산들, 그리고 numpy의 고급 사용법에 대해 알아봅시다.
<br></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><br><br></p>
<p><br></p>
<h3 id="1.-내적-(Inner-Product,-Dot-Product)">
<a class="anchor" href="#1.-%EB%82%B4%EC%A0%81-(Inner-Product,-Dot-Product)" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. 내적 (Inner Product, Dot Product)<a class="anchor-link" href="#1.-%EB%82%B4%EC%A0%81-(Inner-Product,-Dot-Product)"> </a>
</h3>
<p>이전 시간에 벡터와 벡터의 합, 벡터와 스칼라의 곱까지 다루었습니다. 이제 벡터와 벡터의 곱을 다뤄볼까 합니다. 벡터와 벡터를 곱하는 방법은 두가지가 있습니다. 첫번째는 내적, 두번째는 외적입니다. 내적, 외적은 어려워 보여서 많이들 꺼려하시는데요. 사실 그 이름의 의미만 알면 굉장히 쉬운 개념입니다. 우선 외/내적을 부를때, '적'은 한자로 '쌓을 적'에 해당하고(적재하다 할때 '적') 여기에서는 곱한다라고 이해하시면 됩니다. 그러면 왜 '내', '외'가 붙을까요?
<br><br></p>
<p>먼저 내적은 벡터와 벡터를 곱하는 방법 중 하나입니다. <strong>내적이라고 할때 '내'는 inner, 즉 안쪽을 의미</strong>합니다. 왜 '내'적이냐면, <strong>A $\cdot$ B와 같이 내적할 때, B를 A가 존재하는 방향 '안'으로 넣은 상태에서 크기를 곱하기 때문</strong>입니다. 그에 비해 외적은 B와 A 모두가 존재하는 방향의 '밖'에서 크기를 곱하기 때문에 '외'적이라고 부릅니다. (본 강의에서는 내적만 다룹니다. 실제 선형대수 전체 내용에서는 외적도 다루지만 머신러닝 프로그래밍을 할 때 여러분이 외적을 수행하는 경우는 거의 없습니다.)
<br><br></p>
<p>그냥 길이만 곱하면 되지 무슨 어렵게 내적, 외적이냐고 하실 수 있는데, 기본적으로 벡터는 방향을 가진 데이터이기 때문에 더할때도 방향을 고려해줘야하고, 곱할 때도 방향을 맞추고 나서 계산해야합니다. 때문에 내적의 경우에는 두 요소 중 한 요소의 방향에 맞춘 뒤, 크기를 곱하는 것이고, 외적은 두 요소를 모두 새로운 방향에 놓고 크기를 곱하는 것입니다.</p>
<p><br></p>
<h4 id="1.1.-벡터-벡터-내적-(Vector-Vector-Inner-Product)">
<a class="anchor" href="#1.1.-%EB%B2%A1%ED%84%B0-%EB%B2%A1%ED%84%B0-%EB%82%B4%EC%A0%81-(Vector-Vector-Inner-Product)" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.1. 벡터-벡터 내적 (Vector-Vector Inner Product)<a class="anchor-link" href="#1.1.-%EB%B2%A1%ED%84%B0-%EB%B2%A1%ED%84%B0-%EB%82%B4%EC%A0%81-(Vector-Vector-Inner-Product)"> </a>
</h4>
<p>벡터와 벡터의 내적은 아래처럼 구합니다. 아래 애니메이션을 보면 $\vec{v}$와 $\vec{w}$를 내적하고 있습니다. 먼저 식($\vec{v} \cdot \vec{w}$) 에서 뒷쪽에 있는 $\vec{w}$를 $\vec{v}$가 있는 방향 속으로 넣습니다. 이 것을 투영(projection)이라고 합니다.</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/71.gif?raw=true" alt="image.png">
<br><br></p>
<p>그리고 나서  $\vec{w}$가 있는 공간으로 투영된 $\vec{v}$와 $\vec{w}$의 크기를 서로 곱합니다. 이렇게 '내'적은 한 요소를 다른 요소가 존재하는 공간 안으로 넣어서 크기를 곱하기 때문에 그러한 이름이 붙은 것입니다.</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/72.gif?raw=true" alt="image.png">
<br><br></p>
<p>만약 두 벡터의 방향이 같다면 내적의 결과는 양수가 되고, 두 벡터가 수직이라면 다른 벡터에 투영했을 때, 길이가 0이 되므로 결과 값은 0이 됩니다.</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/77.gif?raw=true" alt="image.png">
<br><br></p>
<p>그리고 만약 두 벡터가 방향이 반대라면, 내적의 결과는 음수가 됩니다.</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/73.gif?raw=true" alt="image.png">
<br><br></p>
<p>내적을 계산할 땐, 대부분 cos을 사용해서 계산하는데요. $\vec{v}$의 norm과 $\vec{w}$의 norm을 그냥 곱하는 것이 아니라, $\vec{v}$가 투영된 길이만큼 곱해야합니다. 투영된 길이가 바로 $\vec{v} \cos \theta$입니다.</p>
<p><img src="https://qph.fs.quoracdn.net/main-qimg-234168ed4b95aa311a4cd1d8985253e7" alt="">
<br></p>
<p>근데 매번 코사인 각도를 측정해서 계산하는 것은 너무 비효율적이고 복잡합니다. 따라서 우리는 주로 내적을 계산할 때 이렇게 계산하지 않고 아래처럼 계산합니다. (계산 결과는 하나의 Scalar가 됩니다)</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/74.gif?raw=true" alt="image.png"></p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/75.gif?raw=true" alt="image.png"></p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/76.gif?raw=true" alt="image.png">
<br><br></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>내적연산은 numpy의 @ 연산자를 통해 수행할 수 있습니다.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


<span class="n">vec_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">vec_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

<span class="n">vec_a</span> <span class="o">@</span> <span class="n">vec_b</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>8</pre>
</div>

</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>계산 결과는 2 x 3 + 1 x 2로 8이 됩니다. 이렇게 계산한 방법과 위의 투영을 통한 cos곱과 결과가 같습니다. 이 둘이 왜 동일한 연산인지 이해하기 위해서는 아래부터 이야기할 행렬에 대한 이해가 필요합니다. 따라서 이 내용은 가장 마지막에 다시 이야기 하도록 하겠습니다.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><br><br></p>
<h3 id="2.-행렬">
<a class="anchor" href="#2.-%ED%96%89%EB%A0%AC" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. 행렬<a class="anchor-link" href="#2.-%ED%96%89%EB%A0%AC"> </a>
</h3>
<p>행렬은 이미 많이 들어봐서 알고 있을 것입니다. 그러나 행렬이 진정으로 무엇을 의미하는지는 학교에서 잘 가르쳐주지 않습니다. 행렬을 알기 전에 "변환", 즉 "Transformation"이라는 단어에 대해 먼저 생각해봅시다. <br><br></p>
<h4 id="2.1.-변환-(Transformation)">
<a class="anchor" href="#2.1.-%EB%B3%80%ED%99%98-(Transformation)" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.1. 변환 (Transformation)<a class="anchor-link" href="#2.1.-%EB%B3%80%ED%99%98-(Transformation)"> </a>
</h4>
<p>변환은 함수와 어느정도 일맥상통합니다. 함수는 어떤 수를 입력받아서 다른 수로 변환합니다.</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/31.gif?raw=true" alt="img">
<br><br></p>
<p>선형대수의 맥락에서 보자면, 특정 벡터를 다른 벡터로 변환하는 것이라고 볼 수 있습니다.</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/32.gif?raw=true" alt="img">
<br><br></p>
<p>즉 아래와 같이 어떤 입력벡터를 움직여서 출력 벡터로 만드는 것을 생각해볼 수 있습니다.</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/33.gif?raw=true" alt="img">
<br><br></p>
<p>이러한 변환을 공간 전체에 있는 모든 벡터에 적용한다면, 아래처럼 진행이 될 수 있습니다. 공간에 있는 모든 벡터가 위와 같이 회전하거나 변환됩니다.</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/41.gif?raw=true" alt="img">
<br><br><br></p>
<h4 id="2.2.-선형-변환-(Linear-Transformation)">
<a class="anchor" href="#2.2.-%EC%84%A0%ED%98%95-%EB%B3%80%ED%99%98-(Linear-Transformation)" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.2. 선형 변환 (Linear Transformation)<a class="anchor-link" href="#2.2.-%EC%84%A0%ED%98%95-%EB%B3%80%ED%99%98-(Linear-Transformation)"> </a>
</h4>
<p>그러나, 선형대수에서는 모든 종류의 변환을 다루지 않습니다. 선형대수에서는 모든 벡터가 선형성을 유지해야하기 때문에 "선형 변환"에 대하서만 다루고, "비 선형 변환"은 다루지 않습니다. 시각적으로 볼 때, 변환이 선형적(Linear)하다는 것은 두가지 속성을 의미합니다. 
<br><br></p>
<ul>
<li>모든 벡터는 변환 이후에도 휘지 않고 직선이여야 한다. </li>
<li>원점은 변환 이후에도 그대로 원점(0, 0)이여야 한다.</li>
</ul>
<p><br></p>
<p>두가지 조건을 만족하지 않는 경우 선형변환이라고 하지 않습니다. 아래처럼 변환 이후에 직선이 휘어서 곡선이 되어있거나, 원점이 다른 곳으로 이동하면 그러한 변환은 선형변환이 아닌, 비선형 변환입니다.</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/42.gif?raw=true" alt="img">
<br><br></p>
<h4 id="2.3.-굳이-변환-이야기를-꺼내는-이유?">
<a class="anchor" href="#2.3.-%EA%B5%B3%EC%9D%B4-%EB%B3%80%ED%99%98-%EC%9D%B4%EC%95%BC%EA%B8%B0%EB%A5%BC-%EA%BA%BC%EB%82%B4%EB%8A%94-%EC%9D%B4%EC%9C%A0?" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.3. 굳이 변환 이야기를 꺼내는 이유?<a class="anchor-link" href="#2.3.-%EA%B5%B3%EC%9D%B4-%EB%B3%80%ED%99%98-%EC%9D%B4%EC%95%BC%EA%B8%B0%EB%A5%BC-%EA%BA%BC%EB%82%B4%EB%8A%94-%EC%9D%B4%EC%9C%A0?"> </a>
</h4>
<p>선형 변환에 대해서 말씀 드린 이유는, 행렬이 바로 벡터를 선형 변환시키기 위한 도구이기 때문입니다. 선형대수의 장점은 하나의 연산이나 하나의 벡터에 대해 기하학적인 표현과 수치적인 표현이 모두 가능하다는 것에 있다고 이전에 말했습니다. 저는 지금까지 행렬에 대해서 기하학적으로 열심히 설명했던 것 입니다. 그러면 이러한 변환을 우리가 어떻게 수치적으로 계산할 수 있을까요?
<br><br></p>
<p>예를 들어 $\vec{v}$ = $\begin{bmatrix} -1 \\ 2 \end{bmatrix}$라는 벡터가 변환 되었다고 합시다. 그러면 어떻게 이 변환 함수를 찾아낼 수 있을까요? 이 변환이 어떤 변환이였는지 계산하려면, 우리는 기저벡터가 어디에서 어디로 이동했는지만 알면 됩니다. 이 부분을 이해하기 위해서 앞 선 챕터에서 기저벡터에 대해 언급 했던 것 입니다.</p>
<p><br></p>
<p>xy 평면공간의 정규직교 기저벡터는 $\hat{i}$ = $\begin{bmatrix} 1 \\ 0 \end{bmatrix}$과 $\hat{j}$ = $\begin{bmatrix} 0 \\ 1 \end{bmatrix}$입니다. 그리고 $\begin{bmatrix} -1 \\ 2 \end{bmatrix}$는 -1$\hat{i}$ + 2$\hat{j}$가 됩니다. 여기까지는 이전 챕터에서 이야기 했던 내용입니다.</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/43.gif?raw=true" alt="img">
<br><br></p>
<p>변환을 적용하면, 벡터가 움직인다고 했고, 기저벡터 역시 벡터이기 때문에 움직입니다. 자 이제, 변환이 적용된 이후에 기저벡터를 transformed $\hat{i}$과 transformed $\hat{j}$이라고 해보겠습니다.</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/44.gif?raw=true" alt="img">
<br><br></p>
<p>기존에 변환 전 $\vec{v}$ = $\begin{bmatrix} -1 \\ 2 \end{bmatrix}$ = -1 $\hat{i}$ + 2 $\hat{j}$ 였습니다. 마찬가지로 변환된 transformed $\vec{v}$ = - 1 transformed $\hat{i}$ + 2 transformed $\hat{j}$로 이전의 비율(-1, 2)이 유지됩니다. <br><br></p>
<p>결론적으로 변환 전에 우리가 찾던 벡터 $\vec{v}$(노란색)을 이루는 $\hat{i}$와 $\hat{j}$의 어떠한 선형결합이 변환 후에도 같은 결합으로 유지됩니다. 이 말은 즉, 단순히 $\hat{i}$와 $\hat{j}$가 변환 이후에 어디로 갔는지만 알면 벡터 $\vec{v}$가 어디로 움직였는지도 알 수 있다는 말입니다.</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/45.gif?raw=true" alt="img">
<br><br></p>
<p>변환 결과, 기저 $\hat{i}$는 $\begin{bmatrix} 1 \\ 0 \end{bmatrix}$에서 $\begin{bmatrix} 1 \\ -2 \end{bmatrix}$로 움직였고, $\hat{j}$는 $\begin{bmatrix} 0 \\ 1 \end{bmatrix}$에서 $\begin{bmatrix} 3 \\ 0 \end{bmatrix}$으로 움직였습니다. 따라서 변환된 벡터 $\vec{v}$ = -1 <em> $\begin{bmatrix} 1 \\ -2 \end{bmatrix}$ + 2 </em> $\begin{bmatrix} 3 \\ 0 \end{bmatrix}$이 되고, 이 값은 $\begin{bmatrix} 5 \\ 2 \end{bmatrix}$로 변환된 $\vec{v}$의 위치와 동일합니다.</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/46.gif?raw=true" alt="img">
<br><br></p>
<p>이렇게 기저벡터가 어디로 움직였는지만 알면, 해당 공간의 모든 벡터가 어디로 움직였는지 알 수 있게 됩니다.</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/47.gif?raw=true" alt="img">
<br><br></p>
<h4 id="2.4.-행렬의-본질">
<a class="anchor" href="#2.4.-%ED%96%89%EB%A0%AC%EC%9D%98-%EB%B3%B8%EC%A7%88" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.4. 행렬의 본질<a class="anchor-link" href="#2.4.-%ED%96%89%EB%A0%AC%EC%9D%98-%EB%B3%B8%EC%A7%88"> </a>
</h4>
<p>위의 내용을 정리해서 써봅시다. $\hat{i}$는 $\begin{bmatrix} 1 \\ 0 \end{bmatrix}$에서 $\begin{bmatrix} 1 \\ -2 \end{bmatrix}$로 움직였고, $\hat{j}$는 $\begin{bmatrix} 0 \\ 1 \end{bmatrix}$에서 $\begin{bmatrix} 3 \\ 0 \end{bmatrix}$으로 움직였습니다. 따라서 임의의 벡터 $\vec{v}$ = $\begin{bmatrix} x \\ y \end{bmatrix}$는 변환 후에 x <em> $\begin{bmatrix} 1 \\ -2 \end{bmatrix}$ + y </em> $\begin{bmatrix} 3 \\ 0 \end{bmatrix}$이 됩니다. 이것을 조금 더 정리해서 쓰면 $\begin{bmatrix} 1x + 3y \\ -2x + 0y \end{bmatrix}$가 됩니다. 이제 슬슬 감이 오시나요?</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/48.gif?raw=true" alt="img">
<br><br></p>
<p>그래서 이 선형 변환 자체를 $\begin{bmatrix} 1 &amp; 3 \\ -2 &amp; 0 \end{bmatrix}$와 같은 하나의 행렬로서 정의할 수 있습니다.
즉, 행렬은 벡터의 위치를 선형 변환 시키는 도구라고 할 수 있습니다.</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/49.gif?raw=true" alt="img">
<br><br></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="3.-Shape">
<a class="anchor" href="#3.-Shape" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. Shape<a class="anchor-link" href="#3.-Shape"> </a>
</h3>
<p>행렬과 벡터의 Shape에 대해 알아봅시다. Shape이란 말 그대로, 행렬이나 벡터의 모양을 의미합니다.
일반적으로 Shape은 (행의 수, 열의 수)로 표기합니다. 우리가 처음 봤던 가장 기본 형태인 2차원 벡터는 
$\begin{bmatrix} 1 \\ -2 \end{bmatrix}$와 같이 표기합니다. 이와 같은 벡터는 (2, 1)의 Shape을 가진다고 할 수 있습니다. 
3차원 벡터인 $\begin{bmatrix} 1 \\ -2 \\ 3 \end{bmatrix}$는 행이 3개이므로 (3, 1)의 Shape를 갖고 
$\begin{bmatrix} 1 &amp; 1 \\ -2 &amp; 0 \end{bmatrix}$과 같은 행렬은 (2, 2)의 Shape를 갖습니다.
흔히, 이런 Shape을 2 x 2와 같이 표현하기도 합니다. numpy를 사용하면 행렬이나 벡터의 Shape을 매우 쉽게 알 수 있습니다.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">vec_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> 
                  <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]])</span>

<span class="c1"># 행 2개, 열 1개</span>
<span class="n">vec_a</span><span class="o">.</span><span class="n">shape</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>(2, 1)</pre>
</div>

</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>위와 같이 np.array 객체에 .shape를 붙이면 현재 객체의 shape를 알 수 있습니다.
몇가지 예시를 더 보겠습니다.
<br></p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">vec_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> 
                  <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span>
                  <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>

<span class="c1"># 행 3개, 열 1개</span>
<span class="n">vec_b</span><span class="o">.</span><span class="n">shape</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>(3, 1)</pre>
</div>

</div>

</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">matrix_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> 
                     <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>

<span class="c1"># 행 2개, 열 2개</span>
<span class="n">matrix_a</span><span class="o">.</span><span class="n">shape</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>(2, 2)</pre>
</div>

</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><br><br></p>
<h3 id="4.-행렬의-연산">
<a class="anchor" href="#4.-%ED%96%89%EB%A0%AC%EC%9D%98-%EC%97%B0%EC%82%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. 행렬의 연산<a class="anchor-link" href="#4.-%ED%96%89%EB%A0%AC%EC%9D%98-%EC%97%B0%EC%82%B0"> </a>
</h3>
<p>벡터 챕터에서는 가장 중요한 기본 연산인 벡터합과 스칼라 곱에 대해 배웠습니다. 행렬은 벡터보다 조금 더 다양한 연산을 가지고 있습니다. 아래에서 차례로 알아봅시다.
<br><br></p>
<h4 id="4.1.-행렬-합-(=-벡터-합,-Matrix-Addition)">
<a class="anchor" href="#4.1.-%ED%96%89%EB%A0%AC-%ED%95%A9-(=-%EB%B2%A1%ED%84%B0-%ED%95%A9,-Matrix-Addition)" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.1. 행렬 합 (= 벡터 합, Matrix Addition)<a class="anchor-link" href="#4.1.-%ED%96%89%EB%A0%AC-%ED%95%A9-(=-%EB%B2%A1%ED%84%B0-%ED%95%A9,-Matrix-Addition)"> </a>
</h4>
<p>행렬 합은 두 행렬을 더 합니다. 벡터 합과 동일한 방식으로 수행됩니다. 각 원소 자리에 있는 수를 더합니다.
주의할 것은 벡터 합이나 행렬 합은 Shape가 동일할 때만 수행 가능합니다. Shape가 다른 경우 더할 수 없습니다.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>shape이 맞는 경우 행렬 합</li>
</ul>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Shape이 동일한 경우 (2, 2) &amp; (2, 2)</span>

<span class="n">matrix_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> 
                     <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>

<span class="n">matrix_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> 
                     <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>

<span class="n">matrix_a</span> <span class="o">+</span> <span class="n">matrix_b</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>array([[2, 2],
       [0, 3]])</pre>
</div>

</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>shape이 맞지 않는 경우 행렬 합</li>
</ul>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Shape이 다른 경우 (2, 2) &amp; (2, 3)</span>

<span class="n">matrix_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> 
                     <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>

<span class="n">matrix_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                     <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">]])</span>

<span class="n">matrix_a</span> <span class="o">+</span> <span class="n">matrix_b</span>
<span class="c1"># Shape 에러 발생!</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_text output_error">
<pre>
<span class="ansi-red-intense-fg ansi-bold">---------------------------------------------------------------------------</span>
<span class="ansi-red-intense-fg ansi-bold">ValueError</span>                                Traceback (most recent call last)
<span class="ansi-green-intense-fg ansi-bold">&lt;ipython-input-25-a6ec0b31b5ac&gt;</span> in <span class="ansi-cyan-fg">&lt;module&gt;</span>
<span class="ansi-green-fg">      7</span>                      [2, 3, 7]])
<span class="ansi-green-fg">      8</span> 
<span class="ansi-green-intense-fg ansi-bold">----&gt; 9</span><span class="ansi-yellow-intense-fg ansi-bold"> </span>matrix_a <span class="ansi-yellow-intense-fg ansi-bold">+</span> matrix_b
<span class="ansi-green-fg">     10</span> <span class="ansi-red-intense-fg ansi-bold"># Shape 에러 발생!</span>

<span class="ansi-red-intense-fg ansi-bold">ValueError</span>: operands could not be broadcast together with shapes (2,2) (2,3) </pre>
</div>
</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>shape이 맞는 경우 벡터 합</li>
</ul>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Shape이 동일한 경우 (2, 1) &amp; (2, 1)</span>

<span class="n">vec_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> 
                  <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]])</span>

<span class="n">vec_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> 
                  <span class="p">[</span><span class="mi">2</span><span class="p">]])</span>

<span class="n">vec_a</span> <span class="o">+</span> <span class="n">vec_b</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>array([[2],
       [0]])</pre>
</div>

</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>shape이 맞지 않는 경우 벡터 합</li>
</ul>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Shape이 다른 경우 (2, 1) &amp; (3, 1)</span>

<span class="n">vec_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> 
                  <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]])</span>

<span class="n">vec_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> 
                  <span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                  <span class="p">[</span><span class="mi">2</span><span class="p">]])</span>

<span class="n">vec_a</span> <span class="o">+</span> <span class="n">vec_b</span>
<span class="c1"># Shape 에러 발생!</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_text output_error">
<pre>
<span class="ansi-red-intense-fg ansi-bold">---------------------------------------------------------------------------</span>
<span class="ansi-red-intense-fg ansi-bold">ValueError</span>                                Traceback (most recent call last)
<span class="ansi-green-intense-fg ansi-bold">&lt;ipython-input-28-9842e485b732&gt;</span> in <span class="ansi-cyan-fg">&lt;module&gt;</span>
<span class="ansi-green-fg">      8</span>                 [2]])
<span class="ansi-green-fg">      9</span> 
<span class="ansi-green-intense-fg ansi-bold">---&gt; 10</span><span class="ansi-yellow-intense-fg ansi-bold"> </span>vec_a <span class="ansi-yellow-intense-fg ansi-bold">+</span> vec_b
<span class="ansi-green-fg">     11</span> <span class="ansi-red-intense-fg ansi-bold"># Shape 에러 발생!</span>

<span class="ansi-red-intense-fg ansi-bold">ValueError</span>: operands could not be broadcast together with shapes (2,1) (3,1) </pre>
</div>
</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><br><br></p>
<h4 id="4.2.-스칼라-곱-(Scalar-Multiplication)">
<a class="anchor" href="#4.2.-%EC%8A%A4%EC%B9%BC%EB%9D%BC-%EA%B3%B1-(Scalar-Multiplication)" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.2. 스칼라 곱 (Scalar Multiplication)<a class="anchor-link" href="#4.2.-%EC%8A%A4%EC%B9%BC%EB%9D%BC-%EA%B3%B1-(Scalar-Multiplication)"> </a>
</h4>
<p>스칼라곱도 벡터에서 하던 방식과 동일하게 하면 됩니다. 모든 원소에 해당 스칼라를 곱합니다.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">matrix_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> 
                     <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>

<span class="n">scalar</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">matrix_a</span> <span class="o">*</span> <span class="n">scalar</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>array([[ 2,  2],
       [-4,  0]])</pre>
</div>

</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><br><br></p>
<h4 id="4.3.-원소곱-(Elementwise-Multiplication)">
<a class="anchor" href="#4.3.-%EC%9B%90%EC%86%8C%EA%B3%B1-(Elementwise-Multiplication)" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.3. 원소곱 (Elementwise Multiplication)<a class="anchor-link" href="#4.3.-%EC%9B%90%EC%86%8C%EA%B3%B1-(Elementwise-Multiplication)"> </a>
</h4>
<p>행렬의 각 자리 원소끼리 곱합니다. 행렬합과 마찬가지로 Shape이 동일해야합니다. * 연산자를 이용해 원소 곱 연산할 수 있습니다.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">matrix_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> 
                     <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>

<span class="n">matrix_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                     <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>

<span class="n">matrix_a</span> <span class="o">*</span> <span class="n">matrix_b</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>array([[ 2,  2],
       [-4,  0]])</pre>
</div>

</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><br>
벡터도 원소 곱이 가능합니다만, 벡터의 정의에 해당하는 2가지 연산(벡터합, 스칼라곱)에 해당되지 않기 때문에 여기에서 소개합니다.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">vec_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> 
                  <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]])</span>

<span class="n">vec_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">],</span> 
                  <span class="p">[</span><span class="mi">2</span><span class="p">]])</span>

<span class="n">vec_a</span> <span class="o">*</span> <span class="n">vec_b</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>array([[ 2],
       [-4]])</pre>
</div>

</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><br><br></p>
<h4 id="4.4.-행렬-벡터-내적-(Matrix-Vector-Inner-Product)">
<a class="anchor" href="#4.4.-%ED%96%89%EB%A0%AC-%EB%B2%A1%ED%84%B0-%EB%82%B4%EC%A0%81-(Matrix-Vector-Inner-Product)" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.4. 행렬-벡터 내적 (Matrix-Vector Inner Product)<a class="anchor-link" href="#4.4.-%ED%96%89%EB%A0%AC-%EB%B2%A1%ED%84%B0-%EB%82%B4%EC%A0%81-(Matrix-Vector-Inner-Product)"> </a>
</h4>
<p>위에서 말한 케이스로, 행렬을 통해 벡터를 선형변환 시키는 연산입니다. 일반적으로 $\begin{bmatrix} a &amp; b \\ c &amp; d \end{bmatrix}$ @ $\begin{bmatrix} x \\ y \end{bmatrix}$와 같은 연산이 있을 때, 대부분은 $\begin{bmatrix} ax + by \\ cx + dy \end{bmatrix}$와 같이 외우셨을 겁니다. (아래처럼)
<br><br></p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/53.gif?raw=true" alt="img">
<br><br></p>
<p>그러나 본질은 여기에 있습니다. 왜 x에 a와 c가 곱해지는지, 왜 y왜 b와 d가 곱해지는지 알아야합니다. x에 a와 c가 곱해지는 이유는 x가 원래 x @ $\begin{bmatrix} 1 \\ 0 \end{bmatrix}$ = $\begin{bmatrix} 1x \\ 0 \end{bmatrix}$이였는데, $\begin{bmatrix} 1 \\ 0 \end{bmatrix}$이 변환 이후에 $\begin{bmatrix} a \\ b \end{bmatrix}$로 변환되었기 때문에 x는 $\begin{bmatrix} ax \\ cx \end{bmatrix}$로 변환됩니다. y는 원래 y @ $\begin{bmatrix} 0 \\ 1 \end{bmatrix}$ = $\begin{bmatrix} 0 \\ 1y \end{bmatrix}$이였는데 $\begin{bmatrix} 0 \\ 1 \end{bmatrix}$이 변환 이후에 $\begin{bmatrix} b \\ d \end{bmatrix}$로 변환되었기 때문에  y는 $\begin{bmatrix} by \\ dy \end{bmatrix}$로 변환됩니다.
<br><br></p>
<p>아래 수식을 보면 더 좋은 직관을 얻을 수 있을 것입니다.</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/50.gif?raw=true" alt="img">
<br><br></p>
<p>이 연산을 내적이라고 부르는 이유는 뒤에 있는 벡터 $\begin{bmatrix} x \\ y \end{bmatrix}$가 변환이 되어 앞에 있는 행렬 $\begin{bmatrix} a &amp; b \\ c &amp; d \end{bmatrix}$의 방향 안으로 들어가기 때문입니다. 벡터의 방향이 행렬에 의해 변하여, 행렬이 가진 방향으로 바뀌므로 우리는 이 연산도 역시 '내적'이라고 부릅니다. 또한 위에서 언급한 벡터-벡터 내적과 계산하는 방법도 매우 비슷합니다. (원소 끼리 곱한뒤 합치는 형태로 연산) 기본적으로 원래 내적이라는게, 한 요소가 방향을 쥐고 있고 다른 요소가 그 요소의 방향에 맞춰서 바뀌면 그걸 내적이라고 부른다고 생각하시면 편합니다.
<br><br></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="4.5.-Shape-규칙-(Rule-of-multiplication)">
<a class="anchor" href="#4.5.-Shape-%EA%B7%9C%EC%B9%99-(Rule-of-multiplication)" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.5. Shape 규칙 (Rule of multiplication)<a class="anchor-link" href="#4.5.-Shape-%EA%B7%9C%EC%B9%99-(Rule-of-multiplication)"> </a>
</h4>
<p>벡터와 행렬 혹은 행렬과 행렬을 내적하려면 내적하려는 두 벡터/행렬의 Shape이 맞아야합니다. 내적을 위해서는 아래와 같은 Shape에 대한 규칙이 있습니다. <br></p>
<p><img src="https://2.bp.blogspot.com/-iuS-Uayk2FA/T_VUQ3nvaiI/AAAAAAAAAhs/ARvCwQFufsc/s1600/matrix_multi.png" alt="">
<br></p>
<ul>
<li>Rule of multiplication : (a, b) * (b, d) → (a, d)</li>
<li>앞쪽 벡터/행렬의 b와 뒤쪽 벡터/행렬의 b는 동일해야한다.</li>
<li>계산결과 나오는 벡터/행렬의 Shape은 (a, d)가 된다.</li>
</ul>
<p><br></p>
<p>이 규칙에 유의하여 계산해야하며, 위에서도 언급했지만 내적의 연산에는 @라는 기호를 사용합니다. 
파이썬에서 * 는 원소곱을 의미하며 @는 내적을 의미합니다.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Shape : (2, 1)</span>
<span class="n">vec_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> 
                  <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]])</span>

<span class="c1"># Shape : (3, 2)</span>
<span class="n">mat_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>

<span class="c1"># Shape : (3, 2) @ (2, 1) = (3, 1)</span>
<span class="n">mat_a</span> <span class="o">@</span> <span class="n">vec_x</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>array([[  1],
       [ -2],
       [-10]])</pre>
</div>

</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><br><br></p>
<h4 id="4.6.-행렬-행렬-내적-(Matrix-Matrix-Inner-Product))">
<a class="anchor" href="#4.6.-%ED%96%89%EB%A0%AC-%ED%96%89%EB%A0%AC-%EB%82%B4%EC%A0%81-(Matrix-Matrix-Inner-Product))" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.6. 행렬-행렬 내적 (Matrix-Matrix Inner Product))<a class="anchor-link" href="#4.6.-%ED%96%89%EB%A0%AC-%ED%96%89%EB%A0%AC-%EB%82%B4%EC%A0%81-(Matrix-Matrix-Inner-Product))"> </a>
</h4>
<p>이제 조금 특별한 연산인 행렬 내적에 대해 소개합니다. 행렬과 행렬을 내적한다는 것은 합성함수를 만드는 것과 동일합니다. 변환에 변환을 적용하는 것은 곧 함수에 함수를 적용하는 것과 동일한 이치이기 때문입니다.
<br><br></p>
<p>여기에서 두가지 변환을 소개하겠습니다. 첫번째는 회전(Rotation)입니다. 여기서는 반시계방향으로 90도 회전해보겠습니다.</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/51.gif?raw=true" alt="img"></p>
<p>회전하고나면 $\hat{i}$는 $\begin{bmatrix} 1 \\ 0 \end{bmatrix}$에서 $\begin{bmatrix} 0 \\ 1 \end{bmatrix}$이 되고, $\hat{j}$는 $\begin{bmatrix} 0 \\ 1 \end{bmatrix}$에서 $\begin{bmatrix} -1 \\ 0 \end{bmatrix}$이 됩니다. 따라서 이 변환은 $\begin{bmatrix} 0 &amp; 1 \\ -1 &amp; 0 \end{bmatrix}$이 됩니다.
<br><br></p>
<p>두번째는 기울이기(Shear)입니다.</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/52.gif?raw=true" alt="img"></p>
<p>회전하고나면 $\hat{i}$는 그대로 $\begin{bmatrix} 1 \\ 0 \end{bmatrix}$이고, $\hat{j}$는 $\begin{bmatrix} 0 \\ 1 \end{bmatrix}$에서 $\begin{bmatrix} 1 \\ 1 \end{bmatrix}$이 됩니다. 따라서 이 변환은 $\begin{bmatrix} 1 &amp; 1 \\ 0 &amp; 1 \end{bmatrix}$이 됩니다.
<br><br></p>
<p>두 행렬을 $\begin{bmatrix} 1 &amp; 1 \\ 0 &amp; 1 \end{bmatrix}$ @ $\begin{bmatrix} 0 &amp; 1 \\ -1 &amp; 0 \end{bmatrix}$과 같이 내적하면 하면 어떻게 될까요? 정답은 두 연산을 차례대로 실행하는 것이 됩니다. (변환을 또 변환시킴)</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/54.gif?raw=true" alt="img">
<br><br></p>
<p>합성된 변환을 계산하면 아래처럼 계산할 수 있는데요. 각각 $\hat{i}$와 $\hat{j}$가 $\begin{bmatrix} 1 \\ 1 \end{bmatrix}$과 $\begin{bmatrix} -1 \\ 0 \end{bmatrix}$으로 이동했기 때문에 합성 변환에 대한 행렬은 $\begin{bmatrix} 1 &amp; 1 \\ -1 &amp; 0 \end{bmatrix}$이 됩니다. 그리고 이 변환은 이전의 두 변환과는 다른 새로운 변환이 됩니다.</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/55.gif?raw=true" alt="img">
<br><br></p>
<p>만약 새로운 벡터가 이 변환에 적용된다면, 아래처럼 순서대로 두개의 행렬을 차례로 수행하게 되고, 이는 두 변환이 하나의 변환으로 합성된 것과 동일한 효과를 줍니다.</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/56.gif?raw=true" alt="img">
<br><br></p>
<p>수치적으로 행렬의 내적을 표현하면 다음과 같습니다. 가장 먼저 $\hat{i}$가 움직일 곳을 찾습니다.</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/57.gif?raw=true" alt="img">
<br><br></p>
<p>기저벡터 $\hat{i}$가 왼쪽의 행렬을 만나 변환되는 것을 생각하면 이 과정이 쉽게 이해 갈 수 있습니다.</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/58.gif?raw=true" alt="img">
<br><br></p>
<p>그리고 나서 $\hat{j}$가 움직일 곳을 찾습니다.</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/59.gif?raw=true" alt="img">
<br><br></p>
<p>마찬가지로 기저벡터 $\hat{j}$가 왼쪽의 행렬을 만나 변환되는 것을 생각하면 이 과정이 쉽게 이해 갈 수 있습니다.</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/60.gif?raw=true" alt="img">
<br><br></p>
<p>이렇게 계산한 결과는 여러분이 기존에 아래처럼 계산한 결과와 동일하며, 실제로는 이 계산과정을 간단하게 마치 공식처럼 풀어낸 것입니다.</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/61.gif?raw=true" alt="img"></p>
<p>이렇게 계산하면 오른쪽 행렬에 있던 기저벡터들이 모두 왼쪽 행렬에 의해 변환된 것으로 생각 할 수 있습니다. <br><br></p>
<p>또한 기존에는 벡터와 행렬 한개만 가지고 변환하려고 했다면, 이 과정은 두개의 행렬을 미리 곱해서 합쳐놓고, 추후에 어떤 벡터가 입력되면 한번에 2개의 변환을 수행하는 것으로 생각 할 수도 있습니다. 이제 numpy를 이용해 행렬의 내적을 계산해봅시다.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">shear</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> 
                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

<span class="n">rotation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> 
                     <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>

<span class="n">new_transform</span> <span class="o">=</span> <span class="n">shear</span> <span class="o">@</span> <span class="n">rotation</span>

<span class="n">new_transform</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>array([[ 1, -1],
       [ 1,  0]])</pre>
</div>

</div>

</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">vec_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">],</span> 
                  <span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

<span class="n">new_vec_a</span> <span class="o">=</span> <span class="n">new_transform</span> <span class="o">@</span> <span class="n">vec_a</span>
<span class="c1"># shear와 반시계방향 90도 rotation 적용</span>

<span class="n">new_vec_a</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>array([[1],
       [2]])</pre>
</div>

</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><br>
마찬가지로 다양한 Shape의 행렬을 계산할 수 있습니다. 이 때 반드시 Shape 규칙을 따르게 됩니다. (Shape 규칙은 굉장히 중요합니다)</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Shape = (3, 2)</span>
<span class="n">mat_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> 
                  <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> 
                  <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>

<span class="c1"># Shape = (2, 5)</span>
<span class="n">mat_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> 
                  <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>

<span class="c1"># Shape = (3, 2) @ (2, 5) = (3, 5)</span>
<span class="n">mat_a</span> <span class="o">@</span> <span class="n">mat_b</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>array([[ 5,  8, 11, 14, 17],
       [ 8, 13, 18, 23, 28],
       [11, 18, 25, 32, 39]])</pre>
</div>

</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><br></p>
<h4 id="4.7.-행렬내적의-교환법칙은-성립하지-않는다?">
<a class="anchor" href="#4.7.-%ED%96%89%EB%A0%AC%EB%82%B4%EC%A0%81%EC%9D%98-%EA%B5%90%ED%99%98%EB%B2%95%EC%B9%99%EC%9D%80-%EC%84%B1%EB%A6%BD%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94%EB%8B%A4?" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.7. 행렬내적의 교환법칙은 성립하지 않는다?<a class="anchor-link" href="#4.7.-%ED%96%89%EB%A0%AC%EB%82%B4%EC%A0%81%EC%9D%98-%EA%B5%90%ED%99%98%EB%B2%95%EC%B9%99%EC%9D%80-%EC%84%B1%EB%A6%BD%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94%EB%8B%A4?"> </a>
</h4>
<p>한 가지 중요한 사항은 행렬내적은 교환법칙이 성립하지 않는다는 것입니다. A @ B와 B @ A가 같지 않습니다. 왜 그런지는 매우 단순한데, 순서를 바꿔서 움직이면 변환 결과가 달라지기 때문입니다. 만약 Shear를 먼저한다면 아래 처럼 움직입니다.</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/62.gif?raw=true" alt="img">
<br><br></p>
<p>그러나 우리가 rotate 먼저 한다면 아래처럼 움직입니다.</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/63.gif?raw=true" alt="img">
<br><br></p>
<p>두 결과가 매우 상이한데, 이는 매우 당연한 것입니다. 때문에 행렬을 곱할 때는 순서를 주의해줘야합니다. 회전 후 기울인 것과 기울이고 회전한 것의 결과가 다르기 때문이죠.</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/64.gif?raw=true" alt="img">
<br><br></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="4.8.-더-높은-차원의-행렬">
<a class="anchor" href="#4.8.-%EB%8D%94-%EB%86%92%EC%9D%80-%EC%B0%A8%EC%9B%90%EC%9D%98-%ED%96%89%EB%A0%AC" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.8. 더 높은 차원의 행렬<a class="anchor-link" href="#4.8.-%EB%8D%94-%EB%86%92%EC%9D%80-%EC%B0%A8%EC%9B%90%EC%9D%98-%ED%96%89%EB%A0%AC"> </a>
</h4>
<p>더 높은 차원에서의 행렬도 크게 다르지 않습니다. 2차원보다 높은 차원인 3차원에서의 연산도 크게 다르지 않습니다. 새로운 기저벡터인 $\hat{k}$가 생긴 것 외에는 계산 방법은 동일합니다.
<br><br></p>
<ul>
<li>$\hat{i}$의 변환</li>
</ul>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/66.gif?raw=true" alt="img">
<br><br></p>
<ul>
<li>$\hat{j}$의 변환</li>
</ul>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/67.gif?raw=true" alt="img">
<br><br></p>
<ul>
<li>$\hat{k}$의 변환</li>
</ul>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/68.gif?raw=true" alt="img">
<br><br></p>
<p>마찬가지로 3차원 행렬은 3차원 공간상에서 벡터가 변환되는 과정을 나타낸 것입니다. 각각 열은 각 기저들 (i, j, k)이 어디로 움질일지를 나타내는 것입니다.</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/65.gif?raw=true" alt="img">
<br><br></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><br></p>
<h4 id="4.9.-벡터-벡터-내적-(Vector-Vector-Inner-Product)">
<a class="anchor" href="#4.9.-%EB%B2%A1%ED%84%B0-%EB%B2%A1%ED%84%B0-%EB%82%B4%EC%A0%81-(Vector-Vector-Inner-Product)" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.9. 벡터-벡터 내적 (Vector-Vector Inner Product)<a class="anchor-link" href="#4.9.-%EB%B2%A1%ED%84%B0-%EB%B2%A1%ED%84%B0-%EB%82%B4%EC%A0%81-(Vector-Vector-Inner-Product)"> </a>
</h4>
<p>이제 가장 처음에 이야기 했던 벡터 내적에 대해 다시 이야기 해봅시다. 벡터의 내적은 한 벡터를 다른 벡터의 방향 안에 넣은 뒤, 투영된 길이와 다른 벡터의 길이를 곱하는 연산이라고 했습니다. 그렇다면 우리는 $\vec{v} \cdot \vec{w}$의 연산을 다시 생각해볼 필요가 있습니다. 예를 하나 들어봅시다. $\begin{bmatrix} 1 \\ 2 \end{bmatrix} \cdot \begin{bmatrix} 3 \\ 4 \end{bmatrix}$를 벡터가 아닌 행렬로써 계산한다고 생각해봅시다. 사실 이 둘은 모두 Shape이 (2, 1)이기 때문에 행렬 내적으로 연산이 불가능합니다. 
<br><br></p>
<p>따라서 아래와 같이 연산하려면 조금 다르게 생각해야합니다.</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/74.gif?raw=true" alt="image.png"></p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/75.gif?raw=true" alt="image.png"></p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/76.gif?raw=true" alt="image.png">
<br><br></p>
<p>먼저 앞의 벡터를 벡터로 생각하는게 아니라 뒤집어서 Shape이 (1, 2)인 행렬로 생각해봅시다. 그렇게 하면 (1, 2)의 행렬과 (2, 1)의 벡터를 내적해서 Shape이 (1, 1)인 단 하나의 Scalar가 되는데, 이 것이 바로 앞서 말한 벡터 내적과 동일한 연산입니다.</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/78.gif?raw=true" alt="image.png">
<br><br></p>
<p>앞서서 행렬에 대해 이야기할 때, 행렬은 하나의 변환이라고 설명했습니다. 내적이라는 것은 다른 벡터를 자기 자신 벡터의 방향에 투영시키는 변환인데, 그러한 변환을 만들기 위해서는 자기 자신 벡터를 뒤집어서 (1, 2)의 Shape을 갖는 행렬로 만들면 그러한 변환이 된다는 것 입니다. 더 자세하게 설명드리고 싶지만 내용이 너무 어렵고 복잡해지는 것 같아서 그 이유에 대한 내용은 생략하겠습니다. 이에 대한 자세한 내용은 3Blue 1Brown의 Linear Algebra 강의 Chapter 9번의 "내적의 쌍대성" <a href="https://www.youtube.com/watch?v=LyGKycYT2v0&amp;t=651s">https://www.youtube.com/watch?v=LyGKycYT2v0&amp;t=651s</a> 을 보면 더욱 자세히 이해할 수 있습니다. (이해가 안가시면 개인적으로 물어보면 답변해드리겠습니다.)</p>
<p><img src="https://github.com/gusdnd852/bigdata-lecture/blob/master/_notebooks/img/Day1/79.gif?raw=true" alt="image.png">
<br><br></p>

</div>
</div>
</div>
</div>





    <br><br>
    <div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = “https://gusdnd852.github.io/linear_algebra_with_numpy_2“;
this.page.identifier = 04. 선형대수와 Numpy 프로그래밍 (2);
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://gusdnd852.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

<a class="u-url" href="/bigdata-lecture/linear_algebra_with_numpy_2" hidden></a>
</article>

<script>
	function run_exec(){
		if("colab" === "binder"){
			if(confirm("이 노트북은 CPU환경인 Binder에서 소스코드를 실행합니다.")){
				var binder_path = "https://mybinder.org/v2/gh/gusdnd852/bigdata-lecture/master?filepath=_notebooks%2F01_04_%EC%84%A0%ED%98%95%EB%8C%80%EC%88%98%EC%99%80_numpy_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_%282%29.ipynb";
				alert("Binder는 Docker기반의 컨테이너를 직접 빌드하기 때문에 시간이 다소 소요됩니다. Build logs의 show버튼을 눌러서 진행상황을 확인하세요");
				window.open(binder_path, "_blank");
							
			}
			
		}else if("colab" === "colab"){
			if(confirm("이 노트북은 GPU환경인 Google Colab에서 소스코드를 실행합니다.")){
				var colab_path = "https://colab.research.google.com/github/gusdnd852/bigdata-lecture/blob/master/_notebooks/01_04_선형대수와_numpy_프로그래밍_(2).ipynb";
				alert("GPU 설정을 위해 Colab 상단 메뉴중, 런타임 → 런타임 유형변경에서 GPU를 선택해주세요. (미선택시 CPU에서 실행됨)");
				window.open(colab_path, "_blank");
			}			
		}else{
			alert("해당 실행환경은 구동이 불가능합니다. Binder와 Google Colab 중 한가지를 선택해주세요.");
		}
	}

    function code_listener() {
	var input_area = document.getElementsByClassName("input_area");

	for(var i = 0 ; i < input_area.length; i++){
		input_area[i].onclick = function(){
			run_exec();
    		}
	}

    } 

    code_listener();
</script>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/bigdata-lecture/"></data>

  <div class="wrapper">
      <div class="footer-col">
	<footer-elem class=px-2>
		<a href="https://github.com/gusdnd852">
			<svg class="social svg-icon">
				<use xlink:href="/bigdata-lecture/assets/minima-social-icons.svg#github"></use>
			</svg>
			<span class="username">Github</span>
		</a>
	</footer-elem>

	<footer-elem class=px-2>
		<a href="https://youtube.com/channel/UCb7DJAuj1LulbY8WEr2EDUw">
			<svg class="social svg-icon">
				<use xlink:href="/bigdata-lecture/assets/minima-social-icons.svg#youtube"></use>
			</svg>
			<span class="username">Youtube</span>
		</a>
	</footer-elem>

	<footer-elem class=px-2>
		<a href="https://www.facebook.com/gusdnd852">
			<svg class="social svg-icon">
				<use xlink:href="/bigdata-lecture/assets/minima-social-icons.svg#facebook"></use>
			</svg>
			<span class="username">Facebook</span>
		</a>
	</footer-elem>
	<br>
	<div class="copyright">
		© Copyright 2020 Hyunwoong Go. All rights reserved.
	</div>
      </div>
  </div>
</footer>
</body>
</html>
